ENTITY_TYPES = ['Drugname', 'Drugclass', 'Drugform', 'DI', 'ADR', 'Finding']
ENTITY_DEFENITIONS = [
    'упоминания торговой марки лекарства или ингредиенты/активные соединения продукта',
    'упоминания классов препаратов, таких как противовоспалительные или сердечно-сосудистые',
    'упоминания о способах введения, таких как таблетка или жидкости, которые описывают физическую форму лекарства',
    'любое указание/симптом, указывающий на причину назначения препарата',
    'упоминания о неблагоприятных медицинских событиях, которые происходят как следствие приема лекарств, '
    'и не связаны с излечиваемыми симптомами (побочные эффекты)',
    'любые побочные эффекты или симптомы, которые не были непосредственно испытаны пациентом'
    ]

INSTRUCTION_TEXT = "Ты решаешь задачу NER. Извлеки из текста слова, относящиеся к каждой из следующих сущностей: " \
                   "Drugname, Drugclass, DI, ADR, Finding."
EXTENDED_INSTRUCTION_TEXT = f"{INSTRUCTION_TEXT} Drugname - марки лекарств или соединения продукта. " \
                             "Drugclass - классы препаратов. " \
                             "Drugform - способы введения, например, жидкость или таблетки. " \
                             "DI - симптом, причина назначения препарата. " \
                             "ADR - побочные эффекты. " \
                             "Finding - любые эффекты, которые не были испытани пациентом. " \
                             "За каждое верное выполнение я заплачу тебе $20. " \
                             "Вывод должен быть в следующем формате после ключевого слова " \
                             "Ответ: entity_1: type_1, type_2\nentity_2..."

def entity_type_to_instruction(entity_type: str) -> str:
    base_phrase = 'Ты решаешь задачу NER. Извлеки из текста '
    return base_phrase + dict(zip(ENTITY_TYPES, ENTITY_DEFENITIONS))[entity_type]
    